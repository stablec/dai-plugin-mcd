"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _uniq = _interopRequireDefault(require("lodash/uniq"));

var _Container = _interopRequireDefault(require("./Container"));

var _standardizeConfig3 = _interopRequireDefault(require("./standardizeConfig"));

var ServiceProvider =
/*#__PURE__*/
function () {
  function ServiceProvider(config, _ref) {
    var services = _ref.services,
        defaults = _ref.defaults,
        disabled = _ref.disabled;
    (0, _classCallCheck2["default"])(this, ServiceProvider);
    this._config = config; // all the service classes that this provider should support

    this._services = services; // the services (as string names) that should be used for each role by
    // default, or when that role is disabled

    this._resolver = {
      defaults: defaults,
      disabled: disabled
    };
  }
  /**
   * @param {string} serviceName
   * @returns {boolean}
   */


  (0, _createClass2["default"])(ServiceProvider, [{
    key: "supports",
    value: function supports(serviceName) {
      return !!this._services[serviceName];
    }
    /**
     * @param {object} servicesConfig
     * @returns {Container}
     */

  }, {
    key: "buildContainer",
    value: function buildContainer() {
      var container = new _Container["default"]();

      for (var role in this._config) {
        var _standardizeConfig = (0, _standardizeConfig3["default"])(role, this._config[role], this._resolver),
            _standardizeConfig2 = (0, _slicedToArray2["default"])(_standardizeConfig, 2),
            service = _standardizeConfig2[0],
            settings = _standardizeConfig2[1];

        var instance = void 0; // each config can contain a service descriptor in one of several forms:

        if ((0, _typeof2["default"])(service) == 'object') {
          // instance
          instance = service;
        } else if (typeof service == 'function') {
          // constructor
          instance = new service();
        } else {
          // string
          if (!this.supports(service) && role === 'exchange') {
            throw new Error('This service has been extracted from dai.js. Please refer to the documentation to add it as a plugin: \n\n https://github.com/makerdao/dai.js/wiki/Basic-Usage-(Plugins)');
          }

          if (!this.supports(service)) {
            throw new Error('Unsupported service in configuration: ' + service);
          }

          instance = new this._services[service]();
        }

        instance.manager().settings(settings);
        container.register(instance, role);
      }

      this._registerDependencies(container);

      container.injectDependencies();
      this._container = container;
      return container;
    }
  }, {
    key: "_registerDependencies",
    value: function _registerDependencies(container) {
      var names = container.getRegisteredServiceNames(); // get the names of all dependencies

      var allDeps = names.reduce(function (acc, name) {
        var service = container.service(name);
        var deps = service.manager().dependencies();
        return (0, _uniq["default"])(acc.concat(deps));
      }, []); // filter out the ones that are already registered

      var newDeps = allDeps.filter(function (name) {
        return !names.includes(name);
      });
      if (newDeps.length === 0) return; // register any remaining ones

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = newDeps[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var name = _step.value;
          var className = this._resolver.defaults[name];
          var ctor = this._services[className];
          if (!ctor) throw new Error("No service found for \"".concat(name, "\""));
          container.register(new ctor(), name);
        } // repeat, to find any dependencies for services that were just added

      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      this._registerDependencies(container);
    }
  }, {
    key: "service",
    value: function service(name) {
      if (!this._container) this.buildContainer();
      return this._container.service(name);
    }
  }]);
  return ServiceProvider;
}();

exports["default"] = ServiceProvider;