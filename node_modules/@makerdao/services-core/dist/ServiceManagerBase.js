"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _StateMachine = _interopRequireDefault(require("./StateMachine"));

var _ServiceState = _interopRequireDefault(require("./ServiceState"));

var _ServiceType = _interopRequireWildcard(require("./ServiceType"));

var _debug = _interopRequireDefault(require("debug"));

var log = (0, _debug["default"])('dai:ServiceManagerBase');

function _promisify(unsafeCallback) {
  return new Promise(function (resolve, reject) {
    try {
      resolve(unsafeCallback());
    } catch (e) {
      reject(e.message);
    }
  });
}

var ServiceManagerBase =
/*#__PURE__*/
function () {
  /**
   * @param init {function|null}
   * @param connect {function|null}
   * @param auth {function|null}
   */
  function ServiceManagerBase() {
    var init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var connect = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var auth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    (0, _classCallCheck2["default"])(this, ServiceManagerBase);

    // Validate init
    if (init !== null && typeof init !== 'function') {
      throw new Error('Invalid argument init: not a function or null.');
    } else if (init === null) {
      init = function init() {
        return Promise.resolve();
      };
    } // Validate connect


    if (connect !== null && typeof connect !== 'function') {
      throw new Error('Invalid argument connect: not a function or null.');
    } else if (connect === null && auth !== null) {
      connect = function connect() {
        return Promise.resolve();
      };
    } // Validate auth


    if (auth !== null && typeof auth !== 'function') {
      throw new Error('Invalid argument auth: not a function or null.');
    } // Set initial props


    this._init = init;
    this._connect = connect;
    this._auth = auth;
    this._type = auth === null ? connect === null ? _ServiceType["default"].LOCAL : _ServiceType["default"].PUBLIC : _ServiceType["default"].PRIVATE;
    this._state = new _StateMachine["default"](_ServiceState["default"].CREATED, _ServiceType.serviceTypeTransitions[this._type]);
    this._initPromise = null;
    this._connectPromise = null;
    this._authPromise = null;
  }
  /**
   * @returns {Promise}
   */


  (0, _createClass2["default"])(ServiceManagerBase, [{
    key: "initialize",
    value: function initialize(settings) {
      var _this = this;

      // If our current state is preceding the INITIALIZING state, we need to set up initialization
      if (this._state.inState(_ServiceState["default"].CREATED)) {
        // Assert that there is no initPromise at this point

        /* istanbul ignore next */
        if (this._initPromise) {
          throw new Error('Unexpected init promise in state CREATED.');
        } // Enter the INITIALIZING state


        this._state.transitionTo(_ServiceState["default"].INITIALIZING); // After trying to initialize, transition to the success state (READY/OFFLINE) or revert to CREATED


        this._initPromise = _promisify(function () {
          return _this._init(settings);
        }).then(function () {
          return _this._state.transitionTo(_this._type === _ServiceType["default"].LOCAL ? _ServiceState["default"].READY : _ServiceState["default"].OFFLINE);
        }, function (reason) {
          log(reason);

          _this._state.transitionTo(_ServiceState["default"].CREATED);

          throw reason;
        });
      }

      return this._initPromise;
    }
    /**
     * @returns {Promise}
     */

  }, {
    key: "connect",
    value: function connect() {
      var _this2 = this;

      // Local Services are 'connected' whenever they are initialized
      if (this._type === _ServiceType["default"].LOCAL) {
        return this.initialize();
      } // If our current state is preceding the CONNECTING state, we need to set up a new connection


      if (this._state.inState([_ServiceState["default"].CREATED, _ServiceState["default"].INITIALIZING, _ServiceState["default"].OFFLINE]) && this._connectPromise === null) {
        // Make sure to be initialized before trying to connect
        this._connectPromise = this.initialize().then(function () {
          // Enter the CONNECTING state
          _this2._state.transitionTo(_ServiceState["default"].CONNECTING); // After trying to connect, transition to the success state (ONLINE/READY) or revert to OFFLINE.


          return _promisify(function () {
            return _this2._connect(function () {
              return _this2._disconnect();
            });
          }).then(function () {
            // Check if we are still CONNECTING, because another process might have come in between
            if (_this2._state.inState(_ServiceState["default"].CONNECTING)) {
              _this2._state.transitionTo(_this2._type === _ServiceType["default"].PUBLIC ? _ServiceState["default"].READY : _ServiceState["default"].ONLINE);
            }
          }, function (error) {
            log('connect error:', error); // Check if we are still CONNECTING, because another process might have come in between

            if (_this2._state.inState(_ServiceState["default"].CONNECTING)) {
              _this2._state.transitionTo(_ServiceState["default"].OFFLINE);
            }

            throw error;
          });
        });
      }

      return this._connectPromise;
    }
    /**
     * @returns {Promise}
     */

  }, {
    key: "authenticate",
    value: function authenticate() {
      var _this3 = this;

      // Public and Local Services are 'authenticated' whenever they are connected (/initialized)
      if (this._type !== _ServiceType["default"].PRIVATE) {
        return this.connect();
      } // If our current state is preceding the AUTHENTICATING state, we need to set up a new authentication


      if (this._state.inState([_ServiceState["default"].CREATED, _ServiceState["default"].INITIALIZING, _ServiceState["default"].OFFLINE, _ServiceState["default"].CONNECTING, _ServiceState["default"].ONLINE]) && this._authPromise === null) {
        // Make sure to be connected before trying to authenticate
        this._authPromise = this.connect().then(function () {
          // Enter the AUTHENTICATING state
          _this3._state.transitionTo(_ServiceState["default"].AUTHENTICATING); // After trying to authenticate, transition to the success state (READY) or revert to ONLINE


          return _promisify(function () {
            return _this3._auth(function () {
              return _this3._deauthenticate();
            });
          }).then(function () {
            // Check if we are still AUTHENTICATING, because another process might have come in between
            // (Most notably, a disconnect may have transitioned us into OFFLINE state).
            if (_this3._state.inState(_ServiceState["default"].AUTHENTICATING)) {
              _this3._state.transitionTo(_ServiceState["default"].READY);
            }
          }, function (reason) {
            log('authenticate error: ' + reason); // Check if we are still AUTHENTICATING, because another process might have come in between

            if (_this3._state.inState(_ServiceState["default"].AUTHENTICATING)) {
              _this3._state.transitionTo(_ServiceState["default"].ONLINE);
            }
          });
        });
      }

      return this._authPromise;
    }
    /**
     * @returns { ServiceManagerBase }
     */

  }, {
    key: "settings",
    value: function settings(_settings) {
      this._settings = _settings;
      return this;
    }
    /**
     * @returns {string}
     */

  }, {
    key: "state",
    value: function state() {
      return this._state.state();
    }
    /**
     * @returns {string}
     */

  }, {
    key: "type",
    value: function type() {
      return this._type;
    }
    /**
     * @returns {boolean}
     */

  }, {
    key: "isInitialized",
    value: function isInitialized() {
      return !this._state.inState([_ServiceState["default"].CREATED, _ServiceState["default"].INITIALIZING]);
    }
    /**
     * @returns {boolean|null}
     */

  }, {
    key: "isConnected",
    value: function isConnected() {
      return this._type === _ServiceType["default"].LOCAL ? null : this._state.inState([_ServiceState["default"].ONLINE, _ServiceState["default"].AUTHENTICATING, _ServiceState["default"].READY]);
    }
    /**
     * @returns {boolean|null}
     */

  }, {
    key: "isAuthenticated",
    value: function isAuthenticated() {
      return this._type === _ServiceType["default"].PRIVATE ? this._state.inState(_ServiceState["default"].READY) : null;
    }
    /**
     * @returns {boolean}
     */

  }, {
    key: "isReady",
    value: function isReady() {
      return this._state.inState(_ServiceState["default"].READY);
    }
    /**
     * @param {function} handler
     * @returns {ServiceManagerBase}
     */

  }, {
    key: "onInitialized",
    value: function onInitialized(handler) {
      this._state.onStateChanged(function (oldState, newState) {
        if (oldState === _ServiceState["default"].INITIALIZING && (newState === _ServiceState["default"].OFFLINE || newState === _ServiceState["default"].READY)) {
          handler();
        }
      });

      return this;
    }
    /**
     * @param {function} handler
     * @returns {ServiceManagerBase}
     */

  }, {
    key: "onConnected",
    value: function onConnected(handler) {
      this._state.onStateChanged(function (oldState, newState) {
        if (oldState === _ServiceState["default"].CONNECTING && (newState === _ServiceState["default"].ONLINE || newState === _ServiceState["default"].READY)) {
          handler();
        }
      });

      return this;
    }
    /**
     * @param {function} handler
     * @returns {ServiceManagerBase}
     */

  }, {
    key: "onDisconnected",
    value: function onDisconnected(handler) {
      this._state.onStateChanged(function (oldState, newState) {
        if (newState === _ServiceState["default"].OFFLINE && (oldState === _ServiceState["default"].ONLINE || oldState === _ServiceState["default"].READY)) {
          handler();
        }
      });

      return this;
    }
    /**
     * @param {function} handler
     * @returns {ServiceManagerBase}
     */

  }, {
    key: "onAuthenticated",
    value: function onAuthenticated(handler) {
      this._state.onStateChanged(function (oldState, newState) {
        if (oldState === _ServiceState["default"].AUTHENTICATING && newState === _ServiceState["default"].READY) {
          handler();
        }
      });

      return this;
    }
    /**
     * @param {function} handler
     * @returns {ServiceManagerBase}
     */

  }, {
    key: "onDeauthenticated",
    value: function onDeauthenticated(handler) {
      if (this.type() === _ServiceType["default"].PRIVATE) {
        this._state.onStateChanged(function (oldState, newState) {
          if ((newState === _ServiceState["default"].OFFLINE || newState === _ServiceState["default"].ONLINE) && oldState === _ServiceState["default"].READY) {
            handler();
          }
        });
      }

      return this;
    }
    /**
     * @param {function} handler
     * @returns {ServiceManagerBase}
     */

  }, {
    key: "onReady",
    value: function onReady(handler) {
      this._state.onStateChanged(function (_, newState) {
        if (newState === _ServiceState["default"].READY) {
          handler();
        }
      });

      return this;
    }
    /**
     * @param {function} handler
     * @returns {ServiceManagerBase}
     */

  }, {
    key: "onStateChanged",
    value: function onStateChanged(handler) {
      this._state.onStateChanged(handler);

      return this;
    }
    /**
     * This is called by the service implementation object, which is the only authority with knowledge on the true
     * connection status. This will e.g. get called when a ping signal is no longer returned by the back-end and the
     * service implementation object concludes that we are therefore offline.
     *
     * @private
     */

  }, {
    key: "_disconnect",
    value: function _disconnect() {
      /* istanbul ignore next */
      if (this._type === _ServiceType["default"].LOCAL) {
        throw new Error('_disconnect must not be called on a Local Service');
      }

      if (this._state.inState(_ServiceState["default"].AUTHENTICATING)) {
        this._deauthenticate();
      }

      if (this._state.inState([_ServiceState["default"].READY, _ServiceState["default"].ONLINE, _ServiceState["default"].CONNECTING])) {
        this._authPromise = null;
        this._connectPromise = null;

        this._state.transitionTo(_ServiceState["default"].OFFLINE);
      }
    }
    /**
     * This is called by the service implementation object, which is the only authority with knowledge on the true
     * authentication status. This will e.g. get called when an authentication token expires or a user logs out, and the
     * service implementation object concludes that we are therefore no longer authenticated.
     *
     * @private
     */

  }, {
    key: "_deauthenticate",
    value: function _deauthenticate() {
      /* istanbul ignore next */
      if (this._type !== _ServiceType["default"].PRIVATE) {
        throw new Error('_deauthenticate must not be called on a Local or Public Service');
      }

      if (this._state.inState([_ServiceState["default"].READY, _ServiceState["default"].AUTHENTICATING])) {
        this._authPromise = null;

        this._state.transitionTo(_ServiceState["default"].ONLINE);
      }
    }
  }]);
  return ServiceManagerBase;
}();

var _default = ServiceManagerBase;
exports["default"] = _default;