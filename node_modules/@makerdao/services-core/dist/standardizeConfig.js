"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = standardizeConfig;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

function standardizeConfig(role, config, resolver) {
  if (config instanceof Array) {
    if (typeof config[0] == 'boolean' && resolver) {
      return [resolveNameForBoolean(role, config[0], resolver), config[1]];
    }

    return config;
  }

  var className, settings;

  switch ((0, _typeof2["default"])(config)) {
    case 'string':
      // handle a string that refers to a class name
      className = config;
      settings = {};
      break;

    case 'function':
      // handle a service constructor
      className = config;
      settings = {};
      break;

    case 'object':
      // handle a settings object -- use the default version
      className = resolver ? resolveNameForBoolean(role, true, resolver) : true;
      settings = config; // TODO could also handle a service instance or constructor here

      break;

    case 'boolean':
      className = resolver ? resolveNameForBoolean(role, config, resolver) : config;
      settings = {};
      break;

    default:
      throw new Error("could not parse settings for ".concat(role, ":"), config);
  }

  return [className, settings];
}

function resolveNameForBoolean(role, bool, _ref) {
  var defaults = _ref.defaults,
      disabled = _ref.disabled;
  var name;

  if (bool) {
    name = defaults[role];
    if (!name) throw new Error("The \"".concat(role, "\" service has no default"));
  } else {
    name = disabled[role];
    if (!name) throw new Error("The \"".concat(role, "\" service cannot be disabled"));
  }

  return name;
}